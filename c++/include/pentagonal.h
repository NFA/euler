#include <vector>

namespace euler {

/**
 * Pentagonal numbers are generated by the formula, Pn=n(3nâˆ’1)/2. The first ten
 * pentagonal numbers are:
 *
 * 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
 */
template <typename T>
T nth_pentagonal(T ordinal) {
    return (ordinal * (3 * ordinal - T(1)) ) / T(2);
}

template <typename T>
class pentagonal_generator {
public:
  pentagonal_generator() : current(T(1)), count(1) {
    pentagons.push_back(current);
  }
  T operator*() { return current; }
  pentagonal_generator &operator++() {
    current = nth_pentagonal<T>(++count);
    pentagons.push_back(current);
    return *this;
  }
  bool is_pentagonal(T test) {
    if (current == test) {
      return true;
    }
    if (current > test) {
      return check_pentagonal(test);
    }

    do {
      this->operator++();
    } while (current < test);

    if (pentagons.back() == test) {
      return true;
    }
    return false;
  }

  using const_iterator = typename std::vector<T>::const_iterator;
  using value_type     = typename std::vector<T>::value_type;
  using size_type      = typename std::vector<T>::size_type;

  const_iterator begin() const { return std::begin(pentagons); }
  const_iterator end() const { return std::end(pentagons); }

  const value_type& operator[](size_type idx) const {
    return pentagons[idx];
  }
  size_type size() const noexcept { return pentagons.size(); }

private:
  T current;
  int count;
  std::vector<T> pentagons;
  bool check_pentagonal(T test) {
    auto srch = find(std::begin(pentagons), std::end(pentagons), test);
    return srch != std::end(pentagons);
  }
};

} /* namespace euler */
